#!/usr/bin/env python3
"""
Enhanced IWP Laser Visualizer - Unified Sender/Receiver with comprehensive GUI
Professional tool for visualizing and transmitting IWP laser patterns using pygame
"""

import pygame
import math
import time
import os
import re
from typing import List, Tuple, Optional
from iwp_protocol import IWPPoint, IWPPacket, iwp_to_screen_coords, ilda_to_screen_coords
from udp_server import UDPServer
from ilda_integration import IntegratedILDASystem
from ui_widgets import Panel, Button, TextInput, Slider, StatusIndicator, ToggleSwitch
from ui_widgets import WHITE, BLACK, GRAY, DARK_GRAY, GREEN, RED, BLUE, YELLOW, LIGHT_GRAY, ORANGE

class EnhancedLaserVisualizer:
    """Enhanced laser visualizer with unified sender/receiver functionality"""

    @staticmethod
    def _convert_color_to_8bit(r: int, g: int, b: int) -> tuple:
        """Convert IWP colors (which can be 8-bit or 16-bit) to 8-bit pygame colors"""
        r8 = min(255, r >> 8) if r > 255 else r
        g8 = min(255, g >> 8) if g > 255 else g
        b8 = min(255, b >> 8) if b > 255 else b
        return (r8, g8, b8)

    def __init__(self, width: int = 1200, height: int = 800, title: str = "IWP Laser Control Center"):
        self.width = width
        self.height = height
        self.title = title

        # UI Layout dimensions
        self.panel_width = 220
        self.top_panel_height = 80
        self.bottom_panel_height = 60
        self.viz_x = self.panel_width
        self.viz_y = self.top_panel_height
        self.viz_width = self.width - 2 * self.panel_width
        self.viz_height = self.height - self.top_panel_height - self.bottom_panel_height

        # Pygame initialization
        pygame.init()
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption(title)
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 16)

        # Application state
        self.app_mode = "receiver"  # "receiver" or "sender"
        self.running = True

        # Visualization state
        self.current_packet = None
        self.packet_history = []
        self.max_history = 10

        # Display options
        self.show_crosshair = True
        self.show_grid = True
        self.show_blanking = True
        self.show_points = True
        self.show_lines = True
        self.show_info = True
        self.trail_mode = False
        self.point_size = 2

        # Statistics
        self.fps = 0
        self.packet_count = 0
        self.last_packet_time = 0
        self.pattern_type = "Unknown"

        # Network components
        self.udp_server = None

        # ILDA Integration
        self.ilda_system = IntegratedILDASystem()
        self.ilda_packet = None
        self.ilda_file_path = ""
        self.show_file_browser = False
        self.file_browser_files = []
        self.file_browser_selected = 0
        self.current_directory = os.getcwd()

        # Initialize UI
        self._init_ui_panels()

        print(f"Enhanced laser visualizer initialized: {width}x{height}")

    def _init_ui_panels(self):
        """Initialize UI panels and widgets"""
        # Top panel - Mode selection and file operations
        self.top_panel = Panel(0, 0, self.width, self.top_panel_height, "")
        self.top_panel.background_color = (30, 30, 30)

        # Mode toggle button
        self.mode_button = Button(20, 15, 140, 35, "Receiver Mode", self._toggle_app_mode, BLUE)
        self.top_panel.add_widget(self.mode_button)

        # File browser button
        self.file_button = Button(180, 15, 120, 35, "Load ILDA", self._show_file_browser, GRAY)
        self.top_panel.add_widget(self.file_button)

        # Status display
        status_x = self.width - 200
        self.status_text = f"Mode: {self.app_mode.title()}"

        # Connection status indicator
        self.status_indicator = StatusIndicator(self.width - 120, 25, 12, "Network")
        self.top_panel.add_widget(self.status_indicator)

        # Left panel - Network configuration
        panel_y = self.top_panel_height
        panel_height = self.height - self.top_panel_height - self.bottom_panel_height
        self.left_panel = Panel(0, panel_y, self.panel_width, panel_height, "Network Settings")

        y_pos = 40
        spacing = 45\n\n        # IP address input\n        self.ip_input = TextInput(15, y_pos, 190, 30, \"192.168.1.100\", \"Target IP Address\",\n                                 r\"^(\\d{1,3}\\.){0,3}\\d{0,3}$\")\n        self.left_panel.add_widget(self.ip_input)\n        y_pos += spacing\n\n        # Port input\n        self.port_input = TextInput(15, y_pos, 190, 30, \"7200\", \"Port\", r\"^\\d{0,5}$\")\n        self.left_panel.add_widget(self.port_input)\n        y_pos += spacing\n\n        # Scan rate slider\n        self.scan_rate_slider = Slider(15, y_pos, 190, 25, 100, 100000, 1000,\n                                      self._on_scan_rate_change, \"Scan Rate (Hz)\", 0)\n        self.left_panel.add_widget(self.scan_rate_slider)\n        y_pos += spacing + 10\n\n        # FPS slider\n        self.fps_slider = Slider(15, y_pos, 190, 25, 0.1, 120, 25,\n                                self._on_fps_change, \"FPS\", 1)\n        self.left_panel.add_widget(self.fps_slider)\n        y_pos += spacing + 10\n\n        # Loop count input\n        self.loop_input = TextInput(15, y_pos, 190, 30, \"0\", \"Loop Count (0=âˆž)\", r\"^\\d{0,5}$\")\n        self.left_panel.add_widget(self.loop_input)\n        y_pos += spacing\n\n        # Network transmission toggle\n        self.transmission_toggle = ToggleSwitch(15, y_pos, 80, 30, False,\n                                               self._on_transmission_toggle, \"Transmit\")\n        self.left_panel.add_widget(self.transmission_toggle)\n        y_pos += spacing\n\n        # Connect/Test button\n        self.connect_button = Button(15, y_pos, 190, 35, \"Test Connection\", self._test_connection, GREEN)\n        self.left_panel.add_widget(self.connect_button)\n\n        # Right panel - Playback controls and info\n        self.right_panel = Panel(self.width - self.panel_width, panel_y,\n                                self.panel_width, panel_height, \"Playback & Info\")\n\n        y_pos = 40\n\n        # File info display area\n        self.file_info_y = y_pos\n        y_pos += 80\n\n        # Playback controls\n        self.play_button = Button(15, y_pos, 85, 35, \"Play\", self._toggle_ilda_playback, GREEN)\n        self.right_panel.add_widget(self.play_button)\n\n        self.stop_button = Button(110, y_pos, 85, 35, \"Stop\", self._stop_ilda_playback, RED)\n        self.right_panel.add_widget(self.stop_button)\n        y_pos += spacing\n\n        # Frame navigation\n        self.prev_button = Button(15, y_pos, 85, 30, \"Previous\", self._prev_frame, GRAY)\n        self.right_panel.add_widget(self.prev_button)\n\n        self.next_button = Button(110, y_pos, 85, 30, \"Next\", self._next_frame, GRAY)\n        self.right_panel.add_widget(self.next_button)\n        y_pos += 40\n\n        # Speed control\n        self.speed_slider = Slider(15, y_pos, 190, 25, 0.1, 5.0, 1.0,\n                                  self._on_speed_change, \"Speed\", 1)\n        self.right_panel.add_widget(self.speed_slider)\n        y_pos += spacing\n\n        # Loop toggle\n        self.loop_toggle = ToggleSwitch(15, y_pos, 80, 30, True,\n                                       self._on_loop_toggle, \"Loop\")\n        self.right_panel.add_widget(self.loop_toggle)\n\n        # Bottom panel - Status bar\n        self.bottom_panel = Panel(0, self.height - self.bottom_panel_height,\n                                 self.width, self.bottom_panel_height, \"\")\n        self.bottom_panel.background_color = (25, 25, 25)\n\n        # Update UI for current mode\n        self._update_ui_for_mode()\n\n    def _toggle_app_mode(self):\n        \"\"\"Toggle between receiver and sender mode\"\"\"\n        self.app_mode = \"sender\" if self.app_mode == \"receiver\" else \"receiver\"\n        self._update_ui_for_mode()\n        print(f\"Switched to {self.app_mode} mode\")\n\n    def _update_ui_for_mode(self):\n        \"\"\"Update UI elements based on current mode\"\"\"\n        if self.app_mode == \"receiver\":\n            self.mode_button.text = \"ðŸ“¡ Receiver Mode\"\n            self.mode_button.color = BLUE\n            self.transmission_toggle.enabled = False\n            self.connect_button.text = \"Start Server\"\n            self.status_text = \"Mode: Receiver (Waiting for IWP data)\"\n        else:  # sender mode\n            self.mode_button.text = \"ðŸ“¤ Sender Mode\"\n            self.mode_button.color = YELLOW\n            self.transmission_toggle.enabled = True\n            self.connect_button.text = \"Test Connection\"\n            self.status_text = \"Mode: Sender (ILDA to IWP)\"\n\n    def _show_file_browser(self):\n        \"\"\"Show file browser\"\"\"\n        self.show_file_browser = True\n        self._refresh_file_list()\n\n    def _refresh_file_list(self):\n        \"\"\"Refresh file browser list\"\"\"\n        try:\n            files = []\n            if self.current_directory != '/' and self.current_directory != os.path.dirname(self.current_directory):\n                files.append('..')\n\n            for item in sorted(os.listdir(self.current_directory)):\n                item_path = os.path.join(self.current_directory, item)\n                if os.path.isdir(item_path):\n                    files.append(f\"ðŸ“ {item}\")\n                elif item.lower().endswith('.ild'):\n                    files.append(f\"ðŸ“„ {item}\")\n\n            self.file_browser_files = files\n            self.file_browser_selected = 0\n        except Exception as e:\n            print(f\"Error reading directory: {e}\")\n            self.file_browser_files = []\n\n    # Event handler callbacks\n    def _on_scan_rate_change(self, value: float):\n        \"\"\"Handle scan rate slider change\"\"\"\n        if self.app_mode == \"sender\":\n            self.ilda_system.get_sender().set_scan_rate(int(value))\n\n    def _on_fps_change(self, value: float):\n        \"\"\"Handle FPS slider change\"\"\"\n        self.ilda_system.get_player().set_fps(value)\n\n    def _on_speed_change(self, value: float):\n        \"\"\"Handle speed slider change\"\"\"\n        self.ilda_system.get_player().set_speed(value)\n\n    def _on_loop_toggle(self, enabled: bool):\n        \"\"\"Handle loop toggle\"\"\"\n        self.ilda_system.get_player().loop = enabled\n\n    def _on_transmission_toggle(self, enabled: bool):\n        \"\"\"Handle transmission toggle\"\"\"\n        if self.app_mode == \"sender\":\n            if enabled:\n                ip = self.ip_input.get_text()\n                port = int(self.port_input.get_text() or \"7200\")\n                scan_rate = int(self.scan_rate_slider.get_value())\n                success = self.ilda_system.enable_transmission(ip, port, scan_rate)\n                if success:\n                    self.status_indicator.set_status(\"connected\")\n                    print(f\"Transmission enabled to {ip}:{port}\")\n                else:\n                    self.status_indicator.set_status(\"error\")\n                    self.transmission_toggle.set_state(False)\n                    print(\"Failed to enable transmission\")\n            else:\n                self.ilda_system.disable_transmission()\n                self.status_indicator.set_status(\"disconnected\")\n                print(\"Transmission disabled\")\n\n    def _test_connection(self):\n        \"\"\"Test network connection\"\"\"\n        if self.app_mode == \"receiver\":\n            self._start_udp_server()\n        else:\n            # Test sender connection\n            ip = self.ip_input.get_text()\n            port = int(self.port_input.get_text() or \"7200\")\n            # Perform connection test logic here\n            print(f\"Testing connection to {ip}:{port}\")\n\n    def _start_udp_server(self):\n        \"\"\"Start UDP server for receiving IWP data\"\"\"\n        if not self.udp_server:\n            port = int(self.port_input.get_text() or \"7200\")\n            self.udp_server = UDPServer(port=port)\n            self.udp_server.set_packet_callback(self.set_packet)\n            if self.udp_server.start():\n                self.status_indicator.set_status(\"connected\")\n                self.connect_button.text = \"Stop Server\"\n                print(f\"UDP server started on port {port}\")\n            else:\n                self.status_indicator.set_status(\"error\")\n                print(\"Failed to start UDP server\")\n        else:\n            self.udp_server.stop()\n            self.udp_server = None\n            self.status_indicator.set_status(\"disconnected\")\n            self.connect_button.text = \"Start Server\"\n            print(\"UDP server stopped\")\n\n    def _toggle_ilda_playback(self):\n        \"\"\"Toggle ILDA playback\"\"\"\n        player = self.ilda_system.get_player()\n        if player.playing:\n            player.pause()\n            self.play_button.text = \"Play\"\n        else:\n            player.play()\n            self.play_button.text = \"Pause\"\n\n    def _stop_ilda_playback(self):\n        \"\"\"Stop ILDA playback\"\"\"\n        self.ilda_system.get_player().stop()\n        self.play_button.text = \"Play\"\n\n    def _prev_frame(self):\n        \"\"\"Go to previous frame\"\"\"\n        self.ilda_system.get_player().previous_frame()\n\n    def _next_frame(self):\n        \"\"\"Go to next frame\"\"\"\n        self.ilda_system.get_player().next_frame()\n\n    def set_packet(self, packet: IWPPacket, source_address: str):\n        \"\"\"Update display with new packet data (for receiver mode)\"\"\"\n        if self.app_mode == \"receiver\":\n            self.current_packet = packet\n            self.packet_count += 1\n            self.last_packet_time = time.time()\n\n            if len(self.packet_history) >= self.max_history:\n                self.packet_history.pop(0)\n            self.packet_history.append(packet)\n\n    def _draw_visualization_area(self):\n        \"\"\"Draw the main visualization area\"\"\"\n        # Create visualization surface\n        viz_rect = pygame.Rect(self.viz_x, self.viz_y, self.viz_width, self.viz_height)\n        pygame.draw.rect(self.screen, BLACK, viz_rect)\n        pygame.draw.rect(self.screen, GRAY, viz_rect, 1)\n\n        # Set clipping to visualization area for drawing\n        self.screen.set_clip(viz_rect)\n\n        # Draw grid relative to viz area\n        if self.show_grid:\n            self._draw_grid()\n\n        # Draw crosshair\n        if self.show_crosshair:\n            self._draw_crosshair()\n\n        # Draw laser patterns\n        packet_to_draw = None\n        if self.app_mode == \"sender\":\n            self.ilda_packet = self.ilda_system.update()\n            packet_to_draw = self.ilda_packet\n        else:\n            packet_to_draw = self.current_packet\n\n        if packet_to_draw:\n            self._draw_packet(packet_to_draw, viz_rect)\n\n        # Remove clipping\n        self.screen.set_clip(None)\n\n    def _draw_grid(self):\n        \"\"\"Draw coordinate grid in visualization area\"\"\"\n        grid_spacing = 40\n        \n        # Calculate grid relative to viz area\n        start_x = self.viz_x\n        start_y = self.viz_y\n        end_x = self.viz_x + self.viz_width\n        end_y = self.viz_y + self.viz_height\n        center_x = self.viz_x + self.viz_width // 2\n        center_y = self.viz_y + self.viz_height // 2\n\n        # Vertical lines\n        for x in range(start_x, end_x, grid_spacing):\n            pygame.draw.line(self.screen, DARK_GRAY, (x, start_y), (x, end_y), 1)\n\n        # Horizontal lines  \n        for y in range(start_y, end_y, grid_spacing):\n            pygame.draw.line(self.screen, DARK_GRAY, (start_x, y), (end_x, y), 1)\n\n        # Center lines\n        pygame.draw.line(self.screen, GRAY, (center_x, start_y), (center_x, end_y), 2)\n        pygame.draw.line(self.screen, GRAY, (start_x, center_y), (end_x, center_y), 2)\n\n    def _draw_crosshair(self):\n        \"\"\"Draw crosshair in visualization area\"\"\"\n        center_x = self.viz_x + self.viz_width // 2\n        center_y = self.viz_y + self.viz_height // 2\n        size = 20\n\n        pygame.draw.line(self.screen, WHITE, (center_x - size, center_y), (center_x + size, center_y), 1)\n        pygame.draw.line(self.screen, WHITE, (center_x, center_y - size), (center_x, center_y + size), 1)\n        pygame.draw.circle(self.screen, WHITE, (center_x, center_y), 3, 1)\n\n    def _draw_packet(self, packet: IWPPacket, viz_rect: pygame.Rect):\n        \"\"\"Draw packet points in visualization area\"\"\"\n        if packet.point_count == 0:\n            return\n\n        center_x = viz_rect.centerx\n        center_y = viz_rect.centery\n        scale = min(viz_rect.width, viz_rect.height) / 70000  # Scale factor for ILDA coordinates\n\n        screen_points = []\n        for point in packet.points:\n            # Convert ILDA coordinates to screen coordinates\n            screen_x = center_x + int(point.x * scale)\n            screen_y = center_y - int(point.y * scale)  # Flip Y axis\n            screen_points.append((screen_x, screen_y, point))\n\n        # Draw lines\n        if self.show_lines and len(screen_points) > 1:\n            line_points = []\n            for sx, sy, point in screen_points:\n                if not point.blanking:\n                    line_points.append((sx, sy))\n                else:\n                    if len(line_points) > 1:\n                        color = self._convert_color_to_8bit(point.r, point.g, point.b)\n                        if color == (0, 0, 0):\n                            color = GREEN\n                        pygame.draw.lines(self.screen, color, False, line_points, 2)\n                    line_points = []\n            \n            if len(line_points) > 1:\n                pygame.draw.lines(self.screen, GREEN, False, line_points, 2)\n\n        # Draw points\n        if self.show_points:\n            for sx, sy, point in screen_points:\n                if point.blanking and not self.show_blanking:\n                    continue\n\n                if point.blanking:\n                    color = DARK_GRAY\n                    size = max(1, self.point_size - 1)\n                else:\n                    color = self._convert_color_to_8bit(point.r, point.g, point.b)\n                    if color == (0, 0, 0):\n                        color = WHITE\n                    size = self.point_size\n\n                pygame.draw.circle(self.screen, color, (sx, sy), size)\n\n    def _draw_file_info(self):\n        \"\"\"Draw file information in right panel\"\"\"\n        if self.ilda_file_path:\n            filename = os.path.basename(self.ilda_file_path)\n            status = self.ilda_system.get_status()\n            \n            info_x = self.width - self.panel_width + 15\n            info_y = self.top_panel_height + self.file_info_y\n            \n            # File name\n            text = self.small_font.render(f\"File: {filename[:20]}...\", True, WHITE)\n            self.screen.blit(text, (info_x, info_y))\n            \n            # Frame info\n            if status['loaded']:\n                frame_text = f\"Frame: {status['current_frame']}/{status['total_frames']}\"\n                text = self.small_font.render(frame_text, True, WHITE)\n                self.screen.blit(text, (info_x, info_y + 20))\n                \n                # Points info\n                if self.ilda_packet:\n                    points_text = f\"Points: {self.ilda_packet.point_count}\"\n                    text = self.small_font.render(points_text, True, WHITE)\n                    self.screen.blit(text, (info_x, info_y + 40))\n\n    def _draw_status_bar(self):\n        \"\"\"Draw status information in bottom panel\"\"\"\n        status_y = self.height - self.bottom_panel_height + 15\n        \n        # Mode and connection status\n        mode_text = f\"Mode: {self.app_mode.title()}\"\n        text = self.small_font.render(mode_text, True, WHITE)\n        self.screen.blit(text, (20, status_y))\n        \n        # Network stats\n        if self.app_mode == \"sender\" and self.transmission_toggle.state:\n            stats = self.ilda_system.get_network_stats()\n            net_text = f\"Transmitting to {stats['target_ip']}:{stats['port']} | Packets: {stats['packets_sent']}\"\n            text = self.small_font.render(net_text, True, GREEN)\n            self.screen.blit(text, (200, status_y))\n        elif self.app_mode == \"receiver\" and self.udp_server:\n            recv_text = f\"Listening on port {self.port_input.get_text()} | Packets received: {self.packet_count}\"\n            text = self.small_font.render(recv_text, True, BLUE)\n            self.screen.blit(text, (200, status_y))\n        \n        # FPS\n        fps_text = f\"FPS: {self.fps:.1f}\"\n        text = self.small_font.render(fps_text, True, WHITE)\n        self.screen.blit(text, (self.width - 100, status_y))\n\n    def _draw_file_browser(self):\n        \"\"\"Draw file browser overlay\"\"\"\n        if not self.show_file_browser:\n            return\n\n        # Semi-transparent overlay\n        overlay = pygame.Surface((self.width, self.height))\n        overlay.set_alpha(180)\n        overlay.fill(BLACK)\n        self.screen.blit(overlay, (0, 0))\n\n        # Browser window\n        browser_width = min(600, self.width - 100)\n        browser_height = min(400, self.height - 100)\n        browser_x = (self.width - browser_width) // 2\n        browser_y = (self.height - browser_height) // 2\n\n        browser_rect = pygame.Rect(browser_x, browser_y, browser_width, browser_height)\n        pygame.draw.rect(self.screen, (40, 40, 40), browser_rect)\n        pygame.draw.rect(self.screen, WHITE, browser_rect, 2)\n\n        # Title\n        title_text = self.font.render(\"Select ILDA File\", True, WHITE)\n        self.screen.blit(title_text, (browser_x + 20, browser_y + 20))\n\n        # Current directory\n        dir_text = self.small_font.render(f\"ðŸ“ {self.current_directory}\", True, LIGHT_GRAY)\n        self.screen.blit(dir_text, (browser_x + 20, browser_y + 50))\n\n        # File list\n        list_y = browser_y + 80\n        line_height = 25\n        visible_lines = (browser_height - 120) // line_height\n\n        for i, filename in enumerate(self.file_browser_files[:visible_lines]):\n            y_pos = list_y + i * line_height\n            color = YELLOW if i == self.file_browser_selected else WHITE\n\n            # Highlight selection\n            if i == self.file_browser_selected:\n                highlight_rect = pygame.Rect(browser_x + 15, y_pos - 2, browser_width - 30, line_height)\n                pygame.draw.rect(self.screen, (80, 80, 80), highlight_rect)\n\n            file_text = self.small_font.render(filename, True, color)\n            self.screen.blit(file_text, (browser_x + 20, y_pos))\n\n        # Instructions\n        inst_y = browser_y + browser_height - 40\n        instructions = \"â†‘â†“ Navigate | ENTER Select | ESC Cancel\"\n        inst_text = self.small_font.render(instructions, True, LIGHT_GRAY)\n        self.screen.blit(inst_text, (browser_x + 20, inst_y))\n\n    def handle_events(self):\n        \"\"\"Handle pygame events\"\"\"\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.running = False\n                return\n\n            # UI panel event handling\n            if self.show_file_browser:\n                self._handle_file_browser_events(event)\n            else:\n                self.top_panel.handle_event(event)\n                self.left_panel.handle_event(event)\n                self.right_panel.handle_event(event)\n                self.bottom_panel.handle_event(event)\n\n            # Keyboard shortcuts\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_TAB:\n                    self._toggle_app_mode()\n                elif event.key == pygame.K_F1:\n                    self._show_file_browser()\n                elif event.key == pygame.K_g:\n                    self.show_grid = not self.show_grid\n                elif event.key == pygame.K_c:\n                    self.show_crosshair = not self.show_crosshair\n                elif event.key == pygame.K_p:\n                    self.show_points = not self.show_points\n                elif event.key == pygame.K_l:\n                    self.show_lines = not self.show_lines\n\n    def _handle_file_browser_events(self, event):\n        \"\"\"Handle file browser specific events\"\"\"\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_ESCAPE:\n                self.show_file_browser = False\n            elif event.key == pygame.K_UP:\n                self.file_browser_selected = max(0, self.file_browser_selected - 1)\n            elif event.key == pygame.K_DOWN:\n                self.file_browser_selected = min(len(self.file_browser_files) - 1, self.file_browser_selected + 1)\n            elif event.key == pygame.K_RETURN:\n                self._select_file_from_browser()\n\n    def _select_file_from_browser(self):\n        \"\"\"Select file from browser\"\"\"\n        if not self.file_browser_files or self.file_browser_selected >= len(self.file_browser_files):\n            return\n\n        selected = self.file_browser_files[self.file_browser_selected]\n\n        if selected == '..':\n            # Go to parent directory\n            self.current_directory = os.path.dirname(self.current_directory)\n            self._refresh_file_list()\n        elif selected.startswith('ðŸ“'):\n            # Directory\n            dir_name = selected[2:].strip()\n            self.current_directory = os.path.join(self.current_directory, dir_name)\n            self._refresh_file_list()\n        elif selected.startswith('ðŸ“„'):\n            # ILDA file\n            filename = selected[2:].strip()\n            file_path = os.path.join(self.current_directory, filename)\n            if self.ilda_system.load_file(file_path):\n                self.ilda_file_path = file_path\n                print(f\"Loaded ILDA file: {filename}\")\n                self.show_file_browser = False\n                # Auto-switch to sender mode if loading ILDA file\n                if self.app_mode == \"receiver\":\n                    self._toggle_app_mode()\n            else:\n                print(f\"Failed to load ILDA file: {filename}\")\n\n    def update(self):\n        \"\"\"Update application state\"\"\"\n        # Update UI widgets\n        self.top_panel.update()\n        self.left_panel.update()\n        self.right_panel.update()\n        self.bottom_panel.update()\n\n        # Update FPS calculation\n        current_time = time.time()\n        if hasattr(self, 'last_fps_time'):\n            dt = current_time - self.last_fps_time\n            if dt > 0:\n                self.fps = 1.0 / dt\n        self.last_fps_time = current_time\n\n    def render(self):\n        \"\"\"Render the complete interface\"\"\"\n        # Clear screen\n        self.screen.fill(BLACK)\n\n        # Draw main visualization area\n        self._draw_visualization_area()\n\n        # Draw UI panels\n        self.top_panel.draw(self.screen)\n        self.left_panel.draw(self.screen)\n        self.right_panel.draw(self.screen)\n        self.bottom_panel.draw(self.screen)\n\n        # Draw additional info\n        self._draw_file_info()\n        self._draw_status_bar()\n\n        # Draw file browser if active\n        self._draw_file_browser()\n\n        # Update display\n        pygame.display.flip()\n\n    def run(self):\n        \"\"\"Main application loop\"\"\"\n        print(\"Enhanced IWP Visualizer started\")\n        print(\"Controls:\")\n        print(\"  TAB - Toggle Sender/Receiver mode\")\n        print(\"  F1 - Open file browser\")\n        print(\"  G - Toggle grid\")\n        print(\"  C - Toggle crosshair\")\n        print(\"  P - Toggle points\")\n        print(\"  L - Toggle lines\")\n\n        try:\n            while self.running:\n                self.handle_events()\n                self.update()\n                self.render()\n                self.clock.tick(60)  # 60 FPS\n                \n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.cleanup()\n            pygame.quit()\n\n    def cleanup(self):\n        \"\"\"Clean up resources\"\"\"\n        if self.udp_server:\n            self.udp_server.stop()\n        self.ilda_system.disable_transmission()\n        print(\"Enhanced IWP Visualizer stopped\")\n\ndef main():\n    \"\"\"Run the enhanced visualizer\"\"\"\n    import sys\n    import argparse\n\n    parser = argparse.ArgumentParser(description='Enhanced IWP Visualizer with Sender/Receiver modes')\n    parser.add_argument('--ilda-file', type=str, help='Load ILDA file on startup')\n    parser.add_argument('--mode', choices=['sender', 'receiver'], default='receiver', help='Start in sender or receiver mode')\n    parser.add_argument('--width', type=int, default=1200, help='Window width')\n    parser.add_argument('--height', type=int, default=800, help='Window height')\n\n    args = parser.parse_args()\n\n    visualizer = EnhancedLaserVisualizer(width=args.width, height=args.height)\n    \n    # Set initial mode\n    if args.mode == \"sender\":\n        visualizer._toggle_app_mode()\n    \n    # Load ILDA file if provided\n    if args.ilda_file:\n        if visualizer.ilda_system.load_file(args.ilda_file):\n            visualizer.ilda_file_path = args.ilda_file\n            if args.mode != \"sender\":\n                visualizer._toggle_app_mode()  # Switch to sender mode\n            print(f\"Loaded ILDA file: {args.ilda_file}\")\n        else:\n            print(f\"Warning: Could not load ILDA file {args.ilda_file}\")\n\n    visualizer.run()\n\nif __name__ == \"__main__\":\n    main()